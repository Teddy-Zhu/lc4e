{"version":3,"sources":["webpack:////bundle/14.js","webpack:///./~/markdown-it-footnote/index.js"],"names":["webpackJsonp","400","module","exports","render_footnote_anchor_name","tokens","idx","options","env","n","Number","meta","id","toString","prefix","docId","render_footnote_caption","subId","render_footnote_ref","slf","rules","footnote_anchor_name","caption","footnote_caption","refid","render_footnote_block_open","xhtmlOut","render_footnote_block_close","render_footnote_open","render_footnote_close","render_footnote_anchor","md","footnote_def","state","startLine","endLine","silent","oldBMark","oldTShift","oldSCount","oldParentType","pos","label","token","initial","offset","ch","posAfterColon","start","bMarks","tShift","max","eMarks","src","charCodeAt","footnotes","refs","slice","Token","level","push","sCount","parentType","isSpace","blkIndent","block","tokenize","footnote_inline","labelStart","labelEnd","footnoteId","posMax","parseLinkLabel","list","length","inline","parse","footnote_ref","footnoteSubId","count","footnote_tail","i","l","j","t","lastParagraph","current","currentLabel","insideRef","refTokens","filter","tok","type","children","content","concat","pop","helpers","utils","renderer","footnote_block_open","footnote_block_close","footnote_open","footnote_close","footnote_anchor","ruler","before","alt","after","core"],"mappings":"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","file":"/bundle/14.js","sourcesContent":["webpackJsonp([14],{\n\n/***/ 400:\n/***/ function(module, exports) {\n\n\"use strict\";\n// Process footnotes\n//\n'use strict';\n\n////////////////////////////////////////////////////////////////////////////////\n// Renderer partials\n\nfunction render_footnote_anchor_name(tokens, idx, options, env/*, slf*/) {\n  var n = Number(tokens[idx].meta.id + 1).toString();\n  var prefix = '';\n\n  if (typeof env.docId === 'string') {\n    prefix = '-' + env.docId + '-';\n  }\n\n  return prefix + n;\n}\n\nfunction render_footnote_caption(tokens, idx/*, options, env, slf*/) {\n  var n = Number(tokens[idx].meta.id + 1).toString();\n\n  if (tokens[idx].meta.subId > 0) {\n    n += ':' + tokens[idx].meta.subId;\n  }\n\n  return '[' + n + ']';\n}\n\nfunction render_footnote_ref(tokens, idx, options, env, slf) {\n  var id      = slf.rules.footnote_anchor_name(tokens, idx, options, env, slf);\n  var caption = slf.rules.footnote_caption(tokens, idx, options, env, slf);\n  var refid   = id;\n\n  if (tokens[idx].meta.subId > 0) {\n    refid += ':' + tokens[idx].meta.subId;\n  }\n\n  return '<sup class=\"footnote-ref\"><a href=\"#fn' + id + '\" id=\"fnref' + refid + '\">' + caption + '</a></sup>';\n}\n\nfunction render_footnote_block_open(tokens, idx, options) {\n  return (options.xhtmlOut ? '<hr class=\"footnotes-sep\" />\\n' : '<hr class=\"footnotes-sep\">\\n') +\n         '<section class=\"footnotes\">\\n' +\n         '<ol class=\"footnotes-list\">\\n';\n}\n\nfunction render_footnote_block_close() {\n  return '</ol>\\n</section>\\n';\n}\n\nfunction render_footnote_open(tokens, idx, options, env, slf) {\n  var id = slf.rules.footnote_anchor_name(tokens, idx, options, env, slf);\n\n  if (tokens[idx].meta.subId > 0) {\n    id += ':' + tokens[idx].meta.subId;\n  }\n\n  return '<li id=\"fn' + id + '\" class=\"footnote-item\">';\n}\n\nfunction render_footnote_close() {\n  return '</li>\\n';\n}\n\nfunction render_footnote_anchor(tokens, idx, options, env, slf) {\n  var id = slf.rules.footnote_anchor_name(tokens, idx, options, env, slf);\n\n  if (tokens[idx].meta.subId > 0) {\n    id += ':' + tokens[idx].meta.subId;\n  }\n\n  /* ↩ with escape code to prevent display as Apple Emoji on iOS */\n  return ' <a href=\"#fnref' + id + '\" class=\"footnote-backref\">\\u21a9\\uFE0E</a>';\n}\n\n\nmodule.exports = function footnote_plugin(md) {\n  var parseLinkLabel = md.helpers.parseLinkLabel,\n      isSpace = md.utils.isSpace;\n\n  md.renderer.rules.footnote_ref          = render_footnote_ref;\n  md.renderer.rules.footnote_block_open   = render_footnote_block_open;\n  md.renderer.rules.footnote_block_close  = render_footnote_block_close;\n  md.renderer.rules.footnote_open         = render_footnote_open;\n  md.renderer.rules.footnote_close        = render_footnote_close;\n  md.renderer.rules.footnote_anchor       = render_footnote_anchor;\n\n  // helpers (only used in other rules, no tokens are attached to those)\n  md.renderer.rules.footnote_caption      = render_footnote_caption;\n  md.renderer.rules.footnote_anchor_name  = render_footnote_anchor_name;\n\n  // Process footnote block definition\n  function footnote_def(state, startLine, endLine, silent) {\n    var oldBMark, oldTShift, oldSCount, oldParentType, pos, label, token,\n        initial, offset, ch, posAfterColon,\n        start = state.bMarks[startLine] + state.tShift[startLine],\n        max = state.eMarks[startLine];\n\n    // line should be at least 5 chars - \"[^x]:\"\n    if (start + 4 > max) { return false; }\n\n    if (state.src.charCodeAt(start) !== 0x5B/* [ */) { return false; }\n    if (state.src.charCodeAt(start + 1) !== 0x5E/* ^ */) { return false; }\n\n    for (pos = start + 2; pos < max; pos++) {\n      if (state.src.charCodeAt(pos) === 0x20) { return false; }\n      if (state.src.charCodeAt(pos) === 0x5D /* ] */) {\n        break;\n      }\n    }\n\n    if (pos === start + 2) { return false; } // no empty footnote labels\n    if (pos + 1 >= max || state.src.charCodeAt(++pos) !== 0x3A /* : */) { return false; }\n    if (silent) { return true; }\n    pos++;\n\n    if (!state.env.footnotes) { state.env.footnotes = {}; }\n    if (!state.env.footnotes.refs) { state.env.footnotes.refs = {}; }\n    label = state.src.slice(start + 2, pos - 2);\n    state.env.footnotes.refs[':' + label] = -1;\n\n    token       = new state.Token('footnote_reference_open', '', 1);\n    token.meta  = { label: label };\n    token.level = state.level++;\n    state.tokens.push(token);\n\n    oldBMark = state.bMarks[startLine];\n    oldTShift = state.tShift[startLine];\n    oldSCount = state.sCount[startLine];\n    oldParentType = state.parentType;\n\n    posAfterColon = pos;\n    initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]);\n\n    while (pos < max) {\n      ch = state.src.charCodeAt(pos);\n\n      if (isSpace(ch)) {\n        if (ch === 0x09) {\n          offset += 4 - offset % 4;\n        } else {\n          offset++;\n        }\n      } else {\n        break;\n      }\n\n      pos++;\n    }\n\n    state.tShift[startLine] = pos - posAfterColon;\n    state.sCount[startLine] = offset - initial;\n\n    state.bMarks[startLine] = posAfterColon;\n    state.blkIndent += 4;\n    state.parentType = 'footnote';\n\n    if (state.sCount[startLine] < state.blkIndent) {\n      state.sCount[startLine] += state.blkIndent;\n    }\n\n    state.md.block.tokenize(state, startLine, endLine, true);\n\n    state.parentType = oldParentType;\n    state.blkIndent -= 4;\n    state.tShift[startLine] = oldTShift;\n    state.sCount[startLine] = oldSCount;\n    state.bMarks[startLine] = oldBMark;\n\n    token       = new state.Token('footnote_reference_close', '', -1);\n    token.level = --state.level;\n    state.tokens.push(token);\n\n    return true;\n  }\n\n  // Process inline footnotes (^[...])\n  function footnote_inline(state, silent) {\n    var labelStart,\n        labelEnd,\n        footnoteId,\n        token,\n        tokens,\n        max = state.posMax,\n        start = state.pos;\n\n    if (start + 2 >= max) { return false; }\n    if (state.src.charCodeAt(start) !== 0x5E/* ^ */) { return false; }\n    if (state.src.charCodeAt(start + 1) !== 0x5B/* [ */) { return false; }\n\n    labelStart = start + 2;\n    labelEnd = parseLinkLabel(state, start + 1);\n\n    // parser failed to find ']', so it's not a valid note\n    if (labelEnd < 0) { return false; }\n\n    // We found the end of the link, and know for a fact it's a valid link;\n    // so all that's left to do is to call tokenizer.\n    //\n    if (!silent) {\n      if (!state.env.footnotes) { state.env.footnotes = {}; }\n      if (!state.env.footnotes.list) { state.env.footnotes.list = []; }\n      footnoteId = state.env.footnotes.list.length;\n\n      state.md.inline.parse(\n        state.src.slice(labelStart, labelEnd),\n        state.md,\n        state.env,\n        tokens = []\n      );\n\n      token      = state.push('footnote_ref', '', 0);\n      token.meta = { id: footnoteId };\n\n      state.env.footnotes.list[footnoteId] = { tokens: tokens };\n    }\n\n    state.pos = labelEnd + 1;\n    state.posMax = max;\n    return true;\n  }\n\n  // Process footnote references ([^...])\n  function footnote_ref(state, silent) {\n    var label,\n        pos,\n        footnoteId,\n        footnoteSubId,\n        token,\n        max = state.posMax,\n        start = state.pos;\n\n    // should be at least 4 chars - \"[^x]\"\n    if (start + 3 > max) { return false; }\n\n    if (!state.env.footnotes || !state.env.footnotes.refs) { return false; }\n    if (state.src.charCodeAt(start) !== 0x5B/* [ */) { return false; }\n    if (state.src.charCodeAt(start + 1) !== 0x5E/* ^ */) { return false; }\n\n    for (pos = start + 2; pos < max; pos++) {\n      if (state.src.charCodeAt(pos) === 0x20) { return false; }\n      if (state.src.charCodeAt(pos) === 0x0A) { return false; }\n      if (state.src.charCodeAt(pos) === 0x5D /* ] */) {\n        break;\n      }\n    }\n\n    if (pos === start + 2) { return false; } // no empty footnote labels\n    if (pos >= max) { return false; }\n    pos++;\n\n    label = state.src.slice(start + 2, pos - 1);\n    if (typeof state.env.footnotes.refs[':' + label] === 'undefined') { return false; }\n\n    if (!silent) {\n      if (!state.env.footnotes.list) { state.env.footnotes.list = []; }\n\n      if (state.env.footnotes.refs[':' + label] < 0) {\n        footnoteId = state.env.footnotes.list.length;\n        state.env.footnotes.list[footnoteId] = { label: label, count: 0 };\n        state.env.footnotes.refs[':' + label] = footnoteId;\n      } else {\n        footnoteId = state.env.footnotes.refs[':' + label];\n      }\n\n      footnoteSubId = state.env.footnotes.list[footnoteId].count;\n      state.env.footnotes.list[footnoteId].count++;\n\n      token      = state.push('footnote_ref', '', 0);\n      token.meta = { id: footnoteId, subId: footnoteSubId, label: label };\n    }\n\n    state.pos = pos;\n    state.posMax = max;\n    return true;\n  }\n\n  // Glue footnote tokens to end of token stream\n  function footnote_tail(state) {\n    var i, l, j, t, lastParagraph, list, token, tokens, current, currentLabel,\n        insideRef = false,\n        refTokens = {};\n\n    if (!state.env.footnotes) { return; }\n\n    state.tokens = state.tokens.filter(function (tok) {\n      if (tok.type === 'footnote_reference_open') {\n        insideRef = true;\n        current = [];\n        currentLabel = tok.meta.label;\n        return false;\n      }\n      if (tok.type === 'footnote_reference_close') {\n        insideRef = false;\n        // prepend ':' to avoid conflict with Object.prototype members\n        refTokens[':' + currentLabel] = current;\n        return false;\n      }\n      if (insideRef) { current.push(tok); }\n      return !insideRef;\n    });\n\n    if (!state.env.footnotes.list) { return; }\n    list = state.env.footnotes.list;\n\n    token = new state.Token('footnote_block_open', '', 1);\n    state.tokens.push(token);\n\n    for (i = 0, l = list.length; i < l; i++) {\n      token      = new state.Token('footnote_open', '', 1);\n      token.meta = { id: i, label: list[i].label };\n      state.tokens.push(token);\n\n      if (list[i].tokens) {\n        tokens = [];\n\n        token          = new state.Token('paragraph_open', 'p', 1);\n        token.block    = true;\n        tokens.push(token);\n\n        token          = new state.Token('inline', '', 0);\n        token.children = list[i].tokens;\n        token.content  = '';\n        tokens.push(token);\n\n        token          = new state.Token('paragraph_close', 'p', -1);\n        token.block    = true;\n        tokens.push(token);\n\n      } else if (list[i].label) {\n        tokens = refTokens[':' + list[i].label];\n      }\n\n      state.tokens = state.tokens.concat(tokens);\n      if (state.tokens[state.tokens.length - 1].type === 'paragraph_close') {\n        lastParagraph = state.tokens.pop();\n      } else {\n        lastParagraph = null;\n      }\n\n      t = list[i].count > 0 ? list[i].count : 1;\n      for (j = 0; j < t; j++) {\n        token      = new state.Token('footnote_anchor', '', 0);\n        token.meta = { id: i, subId: j, label: list[i].label };\n        state.tokens.push(token);\n      }\n\n      if (lastParagraph) {\n        state.tokens.push(lastParagraph);\n      }\n\n      token = new state.Token('footnote_close', '', -1);\n      state.tokens.push(token);\n    }\n\n    token = new state.Token('footnote_block_close', '', -1);\n    state.tokens.push(token);\n  }\n\n  md.block.ruler.before('reference', 'footnote_def', footnote_def, { alt: [ 'paragraph', 'reference' ] });\n  md.inline.ruler.after('image', 'footnote_inline', footnote_inline);\n  md.inline.ruler.after('footnote_inline', 'footnote_ref', footnote_ref);\n  md.core.ruler.after('inline', 'footnote_tail', footnote_tail);\n};\n\n\n/***/ }\n\n});\n\n\n// WEBPACK FOOTER //\n// /bundle/14.js","// Process footnotes\n//\n'use strict';\n\n////////////////////////////////////////////////////////////////////////////////\n// Renderer partials\n\nfunction render_footnote_anchor_name(tokens, idx, options, env/*, slf*/) {\n  var n = Number(tokens[idx].meta.id + 1).toString();\n  var prefix = '';\n\n  if (typeof env.docId === 'string') {\n    prefix = '-' + env.docId + '-';\n  }\n\n  return prefix + n;\n}\n\nfunction render_footnote_caption(tokens, idx/*, options, env, slf*/) {\n  var n = Number(tokens[idx].meta.id + 1).toString();\n\n  if (tokens[idx].meta.subId > 0) {\n    n += ':' + tokens[idx].meta.subId;\n  }\n\n  return '[' + n + ']';\n}\n\nfunction render_footnote_ref(tokens, idx, options, env, slf) {\n  var id      = slf.rules.footnote_anchor_name(tokens, idx, options, env, slf);\n  var caption = slf.rules.footnote_caption(tokens, idx, options, env, slf);\n  var refid   = id;\n\n  if (tokens[idx].meta.subId > 0) {\n    refid += ':' + tokens[idx].meta.subId;\n  }\n\n  return '<sup class=\"footnote-ref\"><a href=\"#fn' + id + '\" id=\"fnref' + refid + '\">' + caption + '</a></sup>';\n}\n\nfunction render_footnote_block_open(tokens, idx, options) {\n  return (options.xhtmlOut ? '<hr class=\"footnotes-sep\" />\\n' : '<hr class=\"footnotes-sep\">\\n') +\n         '<section class=\"footnotes\">\\n' +\n         '<ol class=\"footnotes-list\">\\n';\n}\n\nfunction render_footnote_block_close() {\n  return '</ol>\\n</section>\\n';\n}\n\nfunction render_footnote_open(tokens, idx, options, env, slf) {\n  var id = slf.rules.footnote_anchor_name(tokens, idx, options, env, slf);\n\n  if (tokens[idx].meta.subId > 0) {\n    id += ':' + tokens[idx].meta.subId;\n  }\n\n  return '<li id=\"fn' + id + '\" class=\"footnote-item\">';\n}\n\nfunction render_footnote_close() {\n  return '</li>\\n';\n}\n\nfunction render_footnote_anchor(tokens, idx, options, env, slf) {\n  var id = slf.rules.footnote_anchor_name(tokens, idx, options, env, slf);\n\n  if (tokens[idx].meta.subId > 0) {\n    id += ':' + tokens[idx].meta.subId;\n  }\n\n  /* ↩ with escape code to prevent display as Apple Emoji on iOS */\n  return ' <a href=\"#fnref' + id + '\" class=\"footnote-backref\">\\u21a9\\uFE0E</a>';\n}\n\n\nmodule.exports = function footnote_plugin(md) {\n  var parseLinkLabel = md.helpers.parseLinkLabel,\n      isSpace = md.utils.isSpace;\n\n  md.renderer.rules.footnote_ref          = render_footnote_ref;\n  md.renderer.rules.footnote_block_open   = render_footnote_block_open;\n  md.renderer.rules.footnote_block_close  = render_footnote_block_close;\n  md.renderer.rules.footnote_open         = render_footnote_open;\n  md.renderer.rules.footnote_close        = render_footnote_close;\n  md.renderer.rules.footnote_anchor       = render_footnote_anchor;\n\n  // helpers (only used in other rules, no tokens are attached to those)\n  md.renderer.rules.footnote_caption      = render_footnote_caption;\n  md.renderer.rules.footnote_anchor_name  = render_footnote_anchor_name;\n\n  // Process footnote block definition\n  function footnote_def(state, startLine, endLine, silent) {\n    var oldBMark, oldTShift, oldSCount, oldParentType, pos, label, token,\n        initial, offset, ch, posAfterColon,\n        start = state.bMarks[startLine] + state.tShift[startLine],\n        max = state.eMarks[startLine];\n\n    // line should be at least 5 chars - \"[^x]:\"\n    if (start + 4 > max) { return false; }\n\n    if (state.src.charCodeAt(start) !== 0x5B/* [ */) { return false; }\n    if (state.src.charCodeAt(start + 1) !== 0x5E/* ^ */) { return false; }\n\n    for (pos = start + 2; pos < max; pos++) {\n      if (state.src.charCodeAt(pos) === 0x20) { return false; }\n      if (state.src.charCodeAt(pos) === 0x5D /* ] */) {\n        break;\n      }\n    }\n\n    if (pos === start + 2) { return false; } // no empty footnote labels\n    if (pos + 1 >= max || state.src.charCodeAt(++pos) !== 0x3A /* : */) { return false; }\n    if (silent) { return true; }\n    pos++;\n\n    if (!state.env.footnotes) { state.env.footnotes = {}; }\n    if (!state.env.footnotes.refs) { state.env.footnotes.refs = {}; }\n    label = state.src.slice(start + 2, pos - 2);\n    state.env.footnotes.refs[':' + label] = -1;\n\n    token       = new state.Token('footnote_reference_open', '', 1);\n    token.meta  = { label: label };\n    token.level = state.level++;\n    state.tokens.push(token);\n\n    oldBMark = state.bMarks[startLine];\n    oldTShift = state.tShift[startLine];\n    oldSCount = state.sCount[startLine];\n    oldParentType = state.parentType;\n\n    posAfterColon = pos;\n    initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]);\n\n    while (pos < max) {\n      ch = state.src.charCodeAt(pos);\n\n      if (isSpace(ch)) {\n        if (ch === 0x09) {\n          offset += 4 - offset % 4;\n        } else {\n          offset++;\n        }\n      } else {\n        break;\n      }\n\n      pos++;\n    }\n\n    state.tShift[startLine] = pos - posAfterColon;\n    state.sCount[startLine] = offset - initial;\n\n    state.bMarks[startLine] = posAfterColon;\n    state.blkIndent += 4;\n    state.parentType = 'footnote';\n\n    if (state.sCount[startLine] < state.blkIndent) {\n      state.sCount[startLine] += state.blkIndent;\n    }\n\n    state.md.block.tokenize(state, startLine, endLine, true);\n\n    state.parentType = oldParentType;\n    state.blkIndent -= 4;\n    state.tShift[startLine] = oldTShift;\n    state.sCount[startLine] = oldSCount;\n    state.bMarks[startLine] = oldBMark;\n\n    token       = new state.Token('footnote_reference_close', '', -1);\n    token.level = --state.level;\n    state.tokens.push(token);\n\n    return true;\n  }\n\n  // Process inline footnotes (^[...])\n  function footnote_inline(state, silent) {\n    var labelStart,\n        labelEnd,\n        footnoteId,\n        token,\n        tokens,\n        max = state.posMax,\n        start = state.pos;\n\n    if (start + 2 >= max) { return false; }\n    if (state.src.charCodeAt(start) !== 0x5E/* ^ */) { return false; }\n    if (state.src.charCodeAt(start + 1) !== 0x5B/* [ */) { return false; }\n\n    labelStart = start + 2;\n    labelEnd = parseLinkLabel(state, start + 1);\n\n    // parser failed to find ']', so it's not a valid note\n    if (labelEnd < 0) { return false; }\n\n    // We found the end of the link, and know for a fact it's a valid link;\n    // so all that's left to do is to call tokenizer.\n    //\n    if (!silent) {\n      if (!state.env.footnotes) { state.env.footnotes = {}; }\n      if (!state.env.footnotes.list) { state.env.footnotes.list = []; }\n      footnoteId = state.env.footnotes.list.length;\n\n      state.md.inline.parse(\n        state.src.slice(labelStart, labelEnd),\n        state.md,\n        state.env,\n        tokens = []\n      );\n\n      token      = state.push('footnote_ref', '', 0);\n      token.meta = { id: footnoteId };\n\n      state.env.footnotes.list[footnoteId] = { tokens: tokens };\n    }\n\n    state.pos = labelEnd + 1;\n    state.posMax = max;\n    return true;\n  }\n\n  // Process footnote references ([^...])\n  function footnote_ref(state, silent) {\n    var label,\n        pos,\n        footnoteId,\n        footnoteSubId,\n        token,\n        max = state.posMax,\n        start = state.pos;\n\n    // should be at least 4 chars - \"[^x]\"\n    if (start + 3 > max) { return false; }\n\n    if (!state.env.footnotes || !state.env.footnotes.refs) { return false; }\n    if (state.src.charCodeAt(start) !== 0x5B/* [ */) { return false; }\n    if (state.src.charCodeAt(start + 1) !== 0x5E/* ^ */) { return false; }\n\n    for (pos = start + 2; pos < max; pos++) {\n      if (state.src.charCodeAt(pos) === 0x20) { return false; }\n      if (state.src.charCodeAt(pos) === 0x0A) { return false; }\n      if (state.src.charCodeAt(pos) === 0x5D /* ] */) {\n        break;\n      }\n    }\n\n    if (pos === start + 2) { return false; } // no empty footnote labels\n    if (pos >= max) { return false; }\n    pos++;\n\n    label = state.src.slice(start + 2, pos - 1);\n    if (typeof state.env.footnotes.refs[':' + label] === 'undefined') { return false; }\n\n    if (!silent) {\n      if (!state.env.footnotes.list) { state.env.footnotes.list = []; }\n\n      if (state.env.footnotes.refs[':' + label] < 0) {\n        footnoteId = state.env.footnotes.list.length;\n        state.env.footnotes.list[footnoteId] = { label: label, count: 0 };\n        state.env.footnotes.refs[':' + label] = footnoteId;\n      } else {\n        footnoteId = state.env.footnotes.refs[':' + label];\n      }\n\n      footnoteSubId = state.env.footnotes.list[footnoteId].count;\n      state.env.footnotes.list[footnoteId].count++;\n\n      token      = state.push('footnote_ref', '', 0);\n      token.meta = { id: footnoteId, subId: footnoteSubId, label: label };\n    }\n\n    state.pos = pos;\n    state.posMax = max;\n    return true;\n  }\n\n  // Glue footnote tokens to end of token stream\n  function footnote_tail(state) {\n    var i, l, j, t, lastParagraph, list, token, tokens, current, currentLabel,\n        insideRef = false,\n        refTokens = {};\n\n    if (!state.env.footnotes) { return; }\n\n    state.tokens = state.tokens.filter(function (tok) {\n      if (tok.type === 'footnote_reference_open') {\n        insideRef = true;\n        current = [];\n        currentLabel = tok.meta.label;\n        return false;\n      }\n      if (tok.type === 'footnote_reference_close') {\n        insideRef = false;\n        // prepend ':' to avoid conflict with Object.prototype members\n        refTokens[':' + currentLabel] = current;\n        return false;\n      }\n      if (insideRef) { current.push(tok); }\n      return !insideRef;\n    });\n\n    if (!state.env.footnotes.list) { return; }\n    list = state.env.footnotes.list;\n\n    token = new state.Token('footnote_block_open', '', 1);\n    state.tokens.push(token);\n\n    for (i = 0, l = list.length; i < l; i++) {\n      token      = new state.Token('footnote_open', '', 1);\n      token.meta = { id: i, label: list[i].label };\n      state.tokens.push(token);\n\n      if (list[i].tokens) {\n        tokens = [];\n\n        token          = new state.Token('paragraph_open', 'p', 1);\n        token.block    = true;\n        tokens.push(token);\n\n        token          = new state.Token('inline', '', 0);\n        token.children = list[i].tokens;\n        token.content  = '';\n        tokens.push(token);\n\n        token          = new state.Token('paragraph_close', 'p', -1);\n        token.block    = true;\n        tokens.push(token);\n\n      } else if (list[i].label) {\n        tokens = refTokens[':' + list[i].label];\n      }\n\n      state.tokens = state.tokens.concat(tokens);\n      if (state.tokens[state.tokens.length - 1].type === 'paragraph_close') {\n        lastParagraph = state.tokens.pop();\n      } else {\n        lastParagraph = null;\n      }\n\n      t = list[i].count > 0 ? list[i].count : 1;\n      for (j = 0; j < t; j++) {\n        token      = new state.Token('footnote_anchor', '', 0);\n        token.meta = { id: i, subId: j, label: list[i].label };\n        state.tokens.push(token);\n      }\n\n      if (lastParagraph) {\n        state.tokens.push(lastParagraph);\n      }\n\n      token = new state.Token('footnote_close', '', -1);\n      state.tokens.push(token);\n    }\n\n    token = new state.Token('footnote_block_close', '', -1);\n    state.tokens.push(token);\n  }\n\n  md.block.ruler.before('reference', 'footnote_def', footnote_def, { alt: [ 'paragraph', 'reference' ] });\n  md.inline.ruler.after('image', 'footnote_inline', footnote_inline);\n  md.inline.ruler.after('footnote_inline', 'footnote_ref', footnote_ref);\n  md.core.ruler.after('inline', 'footnote_tail', footnote_tail);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/markdown-it-footnote/index.js\n// module id = 400\n// module chunks = 14"],"sourceRoot":""}