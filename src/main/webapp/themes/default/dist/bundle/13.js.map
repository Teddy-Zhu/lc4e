{"version":3,"sources":["webpack:////bundle/13.js","webpack:///./~/markdown-it-mark/index.js"],"names":["webpackJsonp","401","module","exports","md","tokenize","state","silent","i","scanned","token","len","ch","start","pos","marker","src","charCodeAt","scanDelims","length","String","fromCharCode","push","content","delimiters","jump","tokens","level","end","open","can_open","close","can_close","postProcess","j","startDelim","endDelim","loneMarkers","max","type","tag","nesting","markup","pop","inline","ruler","before","ruler2"],"mappings":"AAAAA,cAAc,KAERC,IACA,SAASC,EAAQC,GAEvB,YCFAD,GAAAC,QAAA,SAAAC,GAGA,QAAAC,GAAAC,EAAAC,GACA,GAAAC,GAAAC,EAAAC,EAAAC,EAAAC,EACAC,EAAAP,EAAAQ,IACAC,EAAAT,EAAAU,IAAAC,WAAAJ,EAEA,IAAAN,EAAiB,QAEjB,SAAAQ,EAAiC,QAMjC,IAJAN,EAAAH,EAAAY,WAAAZ,EAAAQ,KAAA,GACAH,EAAAF,EAAAU,OACAP,EAAAQ,OAAAC,aAAAN,GAEAJ,EAAA,EAAkB,QAQlB,KANAA,EAAA,IACAD,EAAAJ,EAAAgB,KAAA,aACAZ,EAAAa,QAAAX,EACAD,KAGAH,EAAA,EAAeA,EAAAG,EAASH,GAAA,EACxBE,EAAAJ,EAAAgB,KAAA,aACAZ,EAAAa,QAAAX,IAEAN,EAAAkB,WAAAF,MACAP,SACAU,KAAAjB,EACAE,MAAAJ,EAAAoB,OAAAP,OAAA,EACAQ,MAAArB,EAAAqB,MACAC,KAAA,EACAC,KAAApB,EAAAqB,SACAC,MAAAtB,EAAAuB,WAMA,OAFA1B,GAAAQ,KAAAL,EAAAU,QAEA,EAMA,QAAAc,GAAA3B,GACA,GAAAE,GAAA0B,EACAC,EACAC,EACA1B,EACA2B,KACAb,EAAAlB,EAAAkB,WACAc,EAAAhC,EAAAkB,WAAAL,MAEA,KAAAX,EAAA,EAAeA,EAAA8B,EAAS9B,IACxB2B,EAAAX,EAAAhB,GAEA,KAAA2B,EAAApB,QAIAoB,EAAAP,OAAA,IAIAQ,EAAAZ,EAAAW,EAAAP,KAEAlB,EAAAJ,EAAAoB,OAAAS,EAAAzB,OACAA,EAAA6B,KAAA,YACA7B,EAAA8B,IAAA,OACA9B,EAAA+B,QAAA,EACA/B,EAAAgC,OAAA,KACAhC,EAAAa,QAAA,GAEAb,EAAAJ,EAAAoB,OAAAU,EAAA1B,OACAA,EAAA6B,KAAA,aACA7B,EAAA8B,IAAA,OACA9B,EAAA+B,SAAA,EACA/B,EAAAgC,OAAA,KACAhC,EAAAa,QAAA,GAEA,SAAAjB,EAAAoB,OAAAU,EAAA1B,MAAA,GAAA6B,MACA,MAAAjC,EAAAoB,OAAAU,EAAA1B,MAAA,GAAAa,SAEAc,EAAAf,KAAAc,EAAA1B,MAAA,GAUA,MAAA2B,EAAAlB,QAAA,CAIA,IAHAX,EAAA6B,EAAAM,MACAT,EAAA1B,EAAA,EAEA0B,EAAA5B,EAAAoB,OAAAP,QAAA,eAAAb,EAAAoB,OAAAQ,GAAAK,MACAL,GAGAA,KAEA1B,IAAA0B,IACAxB,EAAAJ,EAAAoB,OAAAQ,GACA5B,EAAAoB,OAAAQ,GAAA5B,EAAAoB,OAAAlB,GACAF,EAAAoB,OAAAlB,GAAAE,IAKAN,EAAAwC,OAAAC,MAAAC,OAAA,kBAAAzC,GACAD,EAAAwC,OAAAG,OAAAD,OAAA,kBAAAb","file":"/bundle/13.js","sourcesContent":["webpackJsonp([13],{\n\n/***/ 401:\n/***/ function(module, exports) {\n\n\"use strict\";\n'use strict';\n\n\nmodule.exports = function ins_plugin(md) {\n  // Insert each marker as a separate text token, and add it to delimiter list\n  //\n  function tokenize(state, silent) {\n    var i, scanned, token, len, ch,\n        start = state.pos,\n        marker = state.src.charCodeAt(start);\n\n    if (silent) { return false; }\n\n    if (marker !== 0x3D/* = */) { return false; }\n\n    scanned = state.scanDelims(state.pos, true);\n    len = scanned.length;\n    ch = String.fromCharCode(marker);\n\n    if (len < 2) { return false; }\n\n    if (len % 2) {\n      token         = state.push('text', '', 0);\n      token.content = ch;\n      len--;\n    }\n\n    for (i = 0; i < len; i += 2) {\n      token         = state.push('text', '', 0);\n      token.content = ch + ch;\n\n      state.delimiters.push({\n        marker: marker,\n        jump:   i,\n        token:  state.tokens.length - 1,\n        level:  state.level,\n        end:    -1,\n        open:   scanned.can_open,\n        close:  scanned.can_close\n      });\n    }\n\n    state.pos += scanned.length;\n\n    return true;\n  }\n\n\n  // Walk through delimiter list and replace text tokens with tags\n  //\n  function postProcess(state) {\n    var i, j,\n        startDelim,\n        endDelim,\n        token,\n        loneMarkers = [],\n        delimiters = state.delimiters,\n        max = state.delimiters.length;\n\n    for (i = 0; i < max; i++) {\n      startDelim = delimiters[i];\n\n      if (startDelim.marker !== 0x3D/* = */) {\n        continue;\n      }\n\n      if (startDelim.end === -1) {\n        continue;\n      }\n\n      endDelim = delimiters[startDelim.end];\n\n      token         = state.tokens[startDelim.token];\n      token.type    = 'mark_open';\n      token.tag     = 'mark';\n      token.nesting = 1;\n      token.markup  = '==';\n      token.content = '';\n\n      token         = state.tokens[endDelim.token];\n      token.type    = 'mark_close';\n      token.tag     = 'mark';\n      token.nesting = -1;\n      token.markup  = '==';\n      token.content = '';\n\n      if (state.tokens[endDelim.token - 1].type === 'text' &&\n          state.tokens[endDelim.token - 1].content === '=') {\n\n        loneMarkers.push(endDelim.token - 1);\n      }\n    }\n\n    // If a marker sequence has an odd number of characters, it's splitted\n    // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the\n    // start of the sequence.\n    //\n    // So, we have to move all those markers after subsequent s_close tags.\n    //\n    while (loneMarkers.length) {\n      i = loneMarkers.pop();\n      j = i + 1;\n\n      while (j < state.tokens.length && state.tokens[j].type === 'mark_close') {\n        j++;\n      }\n\n      j--;\n\n      if (i !== j) {\n        token = state.tokens[j];\n        state.tokens[j] = state.tokens[i];\n        state.tokens[i] = token;\n      }\n    }\n  }\n\n  md.inline.ruler.before('emphasis', 'mark', tokenize);\n  md.inline.ruler2.before('emphasis', 'mark', postProcess);\n};\n\n\n/***/ }\n\n});\n\n\n// WEBPACK FOOTER //\n// /bundle/13.js","'use strict';\n\n\nmodule.exports = function ins_plugin(md) {\n  // Insert each marker as a separate text token, and add it to delimiter list\n  //\n  function tokenize(state, silent) {\n    var i, scanned, token, len, ch,\n        start = state.pos,\n        marker = state.src.charCodeAt(start);\n\n    if (silent) { return false; }\n\n    if (marker !== 0x3D/* = */) { return false; }\n\n    scanned = state.scanDelims(state.pos, true);\n    len = scanned.length;\n    ch = String.fromCharCode(marker);\n\n    if (len < 2) { return false; }\n\n    if (len % 2) {\n      token         = state.push('text', '', 0);\n      token.content = ch;\n      len--;\n    }\n\n    for (i = 0; i < len; i += 2) {\n      token         = state.push('text', '', 0);\n      token.content = ch + ch;\n\n      state.delimiters.push({\n        marker: marker,\n        jump:   i,\n        token:  state.tokens.length - 1,\n        level:  state.level,\n        end:    -1,\n        open:   scanned.can_open,\n        close:  scanned.can_close\n      });\n    }\n\n    state.pos += scanned.length;\n\n    return true;\n  }\n\n\n  // Walk through delimiter list and replace text tokens with tags\n  //\n  function postProcess(state) {\n    var i, j,\n        startDelim,\n        endDelim,\n        token,\n        loneMarkers = [],\n        delimiters = state.delimiters,\n        max = state.delimiters.length;\n\n    for (i = 0; i < max; i++) {\n      startDelim = delimiters[i];\n\n      if (startDelim.marker !== 0x3D/* = */) {\n        continue;\n      }\n\n      if (startDelim.end === -1) {\n        continue;\n      }\n\n      endDelim = delimiters[startDelim.end];\n\n      token         = state.tokens[startDelim.token];\n      token.type    = 'mark_open';\n      token.tag     = 'mark';\n      token.nesting = 1;\n      token.markup  = '==';\n      token.content = '';\n\n      token         = state.tokens[endDelim.token];\n      token.type    = 'mark_close';\n      token.tag     = 'mark';\n      token.nesting = -1;\n      token.markup  = '==';\n      token.content = '';\n\n      if (state.tokens[endDelim.token - 1].type === 'text' &&\n          state.tokens[endDelim.token - 1].content === '=') {\n\n        loneMarkers.push(endDelim.token - 1);\n      }\n    }\n\n    // If a marker sequence has an odd number of characters, it's splitted\n    // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the\n    // start of the sequence.\n    //\n    // So, we have to move all those markers after subsequent s_close tags.\n    //\n    while (loneMarkers.length) {\n      i = loneMarkers.pop();\n      j = i + 1;\n\n      while (j < state.tokens.length && state.tokens[j].type === 'mark_close') {\n        j++;\n      }\n\n      j--;\n\n      if (i !== j) {\n        token = state.tokens[j];\n        state.tokens[j] = state.tokens[i];\n        state.tokens[i] = token;\n      }\n    }\n  }\n\n  md.inline.ruler.before('emphasis', 'mark', tokenize);\n  md.inline.ruler2.before('emphasis', 'mark', postProcess);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/markdown-it-mark/index.js\n// module id = 401\n// module chunks = 13"],"sourceRoot":""}